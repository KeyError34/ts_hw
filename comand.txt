npm init -y
npm i --save-dev ts-node typescript
npx tsc --init
npx tsc .\src\index.ts
ts-node .\src\index.ts
//compail

"target": "es2016",   // версия js  в которую будет компилится ts
"module": "commonjs", // для роботы с модулями import / export
"esModuleInterop": true, // import / export
"forceConsistentCasingInFileNames": true, // обещание сохрпнить регистр
"strict": true, // строгая проверка типов
"skipLibCheck": true // пропустить проверку типов в файлах обьявлений


Раздел: Projects (Проекты)

1. incremental

Включает сохранение файлов .tsbuildinfo, чтобы ускорить последующую компиляцию проекта.

Пример: Полезно для больших проектов, чтобы не пересобирать весь код.



2. composite

Позволяет использовать проект с другими проектами через ссылки (project references).

Используется, когда твой проект — часть монорепозитория.



3. tsBuildInfoFile

Указывает путь для хранения файла .tsbuildinfo.

По умолчанию хранится в папке сборки.



4. disableSourceOfProjectReferenceRedirect

Отключает предпочтение исходных файлов над декларациями (.d.ts) при ссылках на другие проекты.



5. disableSolutionSearching

Отключает проверку ссылок на другие проекты в режиме редактирования.



6. disableReferencedProjectLoad

Уменьшает количество проектов, которые TypeScript автоматически загружает.





---

Раздел: Language and Environment (Язык и среда)

1. target

Определяет версию JavaScript для выходных файлов.

Значение es2016 означает поддержку современных функций ES6+.



2. lib

Определяет набор стандартных библиотек, которые TypeScript должен учитывать.

Пример: Если нужен DOM, добавь ["dom"].



3. jsx

Указывает, как обрабатывать JSX-код.

Пример: react превращает JSX в React.createElement.



4. experimentalDecorators

Включает поддержку экспериментальных декораторов.

Пример: Используется с библиотеками вроде class-validator.



5. emitDecoratorMetadata

Добавляет метаданные для декораторов.

Требуется, например, для работы с NestJS.



6. jsxFactory и jsxFragmentFactory

Настраивают функции, которые обрабатывают JSX (по умолчанию — React.createElement и React.Fragment).



7. useDefineForClassFields

Использует стандартное поведение для полей классов, как в ECMAScript.





---

Раздел: Modules (Модули)

1. module

Указывает, как генерировать код модулей.

commonjs — стандарт для Node.js.



2. moduleResolution

Определяет, как TypeScript ищет модули.

node подходит для большинства современных проектов.



3. baseUrl и paths

Устанавливают базовую директорию и маппинг путей для импорта модулей.

Пример:

"baseUrl": "./src",
"paths": { "@components/*": ["components/*"] }



4. resolveJsonModule

Разрешает импорт .json файлов.

Пример: import data from './data.json';.



5. esModuleInterop

Генерирует код, облегчающий работу с модулями CommonJS.

Включает allowSyntheticDefaultImports.



6. forceConsistentCasingInFileNames

Требует строгого соблюдения регистра символов в путях.

Полезно для проектов, работающих на разных ОС.





---

Раздел: Emit (Вывод)

1. declaration

Генерирует файлы деклараций .d.ts для каждого .ts файла.



2. sourceMap

Создает файлы .map для отладки с исходным кодом.

Полезно для работы с инструментами разработчика.



3. outDir

Указывает папку для выходных файлов.



4. removeComments

Удаляет комментарии в сгенерированных файлах.



5. noEmit

Запрещает компиляцию файлов. Полезно для проверки ошибок.





---

Раздел: Interop Constraints (Совместимость)

1. isolatedModules

Гарантирует, что каждый файл можно транспилировать отдельно.



2. allowSyntheticDefaultImports

Разрешает использовать import x from "y", даже если модуль не имеет default export.



3. preserveSymlinks

Запрещает преобразовывать символические ссылки в их реальные пути.

Основной блок — Modules

Этот блок отвечает за то, как TypeScript работает с модулями (импортами и экспортами) в вашем проекте.

1. module ("commonjs")

Определяет, какой тип модулей генерировать в итоговом JavaScript.

CommonJS — стандарт модулей, который используется в Node.js (например, require/module.exports).

Другие варианты: ESNext (для современных модулей), AMD, System и т.д.



2. rootDir

Указывает корневую папку для исходных файлов TypeScript.

Например, если у вас код в папке src, вы можете указать: "rootDir": "./src".

Это помогает определить, где искать исходные файлы.



3. moduleResolution

Определяет, как TypeScript будет находить файлы для импорта.

Например, "node10" соответствует логике поиска модулей в Node.js (в папках node_modules).



4. baseUrl

Устанавливает базовую директорию для поиска модулей при использовании относительных путей.

Пример: Если указать "baseUrl": "./src", то import './utils/file' начнёт искать файл в src/utils/file.



5. paths

Используется для сокращения путей при импорте.

Пример:

"paths": {
  "@utils/*": ["src/utils/*"]
}

Теперь можно импортировать файл из src/utils/helper так:
import { helper } from '@utils/helper';.



6. rootDirs

Позволяет TypeScript рассматривать несколько папок как единое пространство для модулей.

Полезно, если у вас есть структура с разделением кода на папки (например, src и shared).



7. typeRoots

Указывает, где искать типы для TypeScript (обычно папка node_modules/@types).

Вы можете указать дополнительные пути к типам, если они хранятся не в стандартном месте.



8. types

Позволяет явно указать библиотеки, типы которых TypeScript должен подключить.

Пример:

"types": ["jest", "node"]



9. allowUmdGlobalAccess

Разрешает доступ к глобальным переменным в UMD модулях.

Полезно, если вы используете библиотеки, которые предоставляют глобальные переменные (например, старые версии jQuery).



10. resolveJsonModule

Позволяет импортировать JSON-файлы как модули.

Пример:

import config from './config.json';
console.log(config.property);



11. allowJs

Разрешает TypeScript обрабатывать JavaScript-файлы в вашем проекте.

Полезно, если вы переходите с JavaScript на TypeScript.



12. checkJs

Если включено, TypeScript начнёт проверять JavaScript-файлы на ошибки (типизацию).



13. noResolve

Запрещает TypeScript автоматически добавлять файлы при использовании import или <reference>.

Полезно, если вы хотите строго ограничить проект только указанными файлами.
